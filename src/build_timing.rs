use std::{
    collections::{BTreeMap, BTreeSet}, fs::File, mem, path::Path
};

use crate::{
    build::{BuildPattern, BuildTimingBuilder, ConstType, ConstVal},
    date_time::DateTime,
    env::{BuildConstVal, BuildTimingConst},
    err::BtResult, CARGO_CLIPPY_ALLOW_ALL,
};

pub(crate) const DEFINE_BUILD_TIMING_RS: &str = "build_timing.rs";
use std::io::Write;

#[derive(Debug)]
pub struct BuildTiming {
    /// The file that `shadow-rs` writes build information to.
    ///
    /// This file will contain all the necessary information about the build, including serialized build constants and other metadata.
    pub f: File,

    /// The values of build constants to be written.
    ///
    /// This is a mapping from `BuildTimingConst` identifiers to their corresponding `ConstVal` objects. Each entry in this map represents a build constant that will be allow in the final build.
    pub map: BTreeMap<BuildTimingConst, ConstVal>,

    /// Constants in the deny list, passed through [`ShadowBuilder::allow_const`].
    ///
    /// This set contains build constant identifiers that should be allow from the build process.
    pub allow_const: BTreeSet<BuildTimingConst>,

    /// The output path where generated files will be placed.
    ///
    /// This specifies the directory where the build script will write its output. It's typically set using the `OUT_DIR` environment variable but can be customized using [`ShadowBuilder::out_path`].
    pub out_path: String,

    /// Determines the strategy for triggering package rebuilds.
    ///
    /// This field sets the pattern for how often the package should be rebuilt. Options include `Lazy`, `RealTime`, and `Custom`, each with its own implications on the build frequency and conditions under which a rebuild is triggered.
    /// It can be configured using [`BuildTimingBuilder::build_pattern`].
    pub build_pattern: BuildPattern,

    pub hook_consts: Vec<Box<dyn BuildConstVal >>,
}

impl BuildTiming {
    pub(crate) fn build_inner(builder: &mut BuildTimingBuilder) -> BtResult<BuildTiming> {
        let out_path = builder.get_out_path()?;
        let build_pattern = builder.get_build_pattern().clone();
        let allow_const = builder.get_allow_const().clone();

        let out = {
            let path = Path::new(out_path);
            if !out_path.ends_with('/') {
                path.join(format!("{out_path}/{DEFINE_BUILD_TIMING_RS}"))
            } else {
                path.join(DEFINE_BUILD_TIMING_RS)
            }
        };

        let mut build_timing = BuildTiming {
            f: File::create(out)?,
            map: Default::default(),
            allow_const,
            out_path: out_path.to_string(),
            build_pattern,
            hook_consts: mem::take(&mut builder.hook_consts),
        };

        for const_name in build_timing.allow_const.iter() {
            build_timing.map.insert(*const_name, const_name.build_val());
        }
        build_timing.write_all()?;

        Ok(build_timing)
    }
    fn gen_header(&self) -> BtResult<()> {
        let desc = format!(
            r#"// Code automatically generated by `shadow-rs` (https://github.com/baoyachi/shadow-rs), do not edit.
// Author: https://www.github.com/baoyachi
// Generation time: {}
"#,
            DateTime::now().to_rfc2822()
        );
        writeln!(&self.f, "{desc}\n\n")?;
        Ok(())
    }

    
    fn write_const(&self, build_timing_const: &str, val: &ConstVal) -> BtResult<()> {
        let desc = format!("#[doc=r#\"{}\"#]", val.desc);
        let define = match val.t {
            ConstType::Str => format!(
                "#[allow(dead_code)]\n\
                {}\n\
            pub const {} :{} = r#\"{}\"#;",
                CARGO_CLIPPY_ALLOW_ALL,
                build_timing_const.to_ascii_uppercase(),
                ConstType::Str,
                val.v
            ),
            ConstType::Bool => format!(
                "#[allow(dead_code)]\n\
            	{}\n\
            pub const {} :{} = {};",
                CARGO_CLIPPY_ALLOW_ALL,
                build_timing_const.to_ascii_uppercase(),
                ConstType::Bool,
                val.v.parse::<bool>().unwrap()
            ),
            ConstType::Slice => format!(
                "#[allow(dead_code)]\n\
            	{}\n\
            pub const {} :{} = &{:?};",
                CARGO_CLIPPY_ALLOW_ALL,
                build_timing_const.to_ascii_uppercase(),
                ConstType::Slice,
                val.v.as_bytes()
            ),
            ConstType::Usize => format!(
                "#[allow(dead_code)]\n\
                {}\n\
            pub const {} :{} = {};",
                CARGO_CLIPPY_ALLOW_ALL,
                build_timing_const.to_ascii_uppercase(),
                ConstType::Usize,
                val.v.parse::<usize>().unwrap_or_default()
            ),
        };

        writeln!(&self.f, "{desc}")?;
        writeln!(&self.f, "{define}\n")?;
        Ok(())
    }

    fn gen_const(&mut self) -> BtResult<()> {
        let out_dir = &self.out_path;
        self.build_pattern.rerun_if(self.map.keys(), out_dir);

        for (k, v) in &self.map {
            self.write_const(&k.to_string(), v)?;
        }

        for const_name in self.hook_consts.iter() {
            self.write_const(&const_name.to_string(), &const_name.build_val())?;
        }

        Ok(())
    }

    fn write_all(&mut self) -> BtResult<()> {
        self.gen_header()?;
        self.gen_const()?;
        Ok(())
    }
}
